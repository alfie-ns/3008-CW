COMP_3008 SET EXERCISES (Neo4j Queries)

- [ ] check if set-exercise 1 code newest gemini's



SET-EXERCISE 1.
Q: "Create a Neo4j database to store the data comprised in the CSV files. The database should respect the data model displayed in the example in the figure below, please note that the image below has had some nodes hidden for clarity. You have to provide all the commands needed to create the database and populate it with the data in the CSV files, and you must provide them in the exact order you propose to execute them. If you create indexes, you must also include the commands for index creation. Your database will be recreated, and the only way to do so is by following the commands that you will provide, in the order in which you provide them."

The database respects the specified data-model, with NO PROPERTIES ON RELATIONSHIPS as per Dr Ansell's instructions. The intermediate nodes i.e. `Entry` and `Vote`, store the detailed attributes of which would otherwise be properties on relationships.

1.1 Data Model

1.2 Database Creation commands

Execute the commands that follow in the exact order shown to recreate the database.

1.2.0- CLEAR EXISTING DATA (CLEAN SLATE):
    MATCH (n) DETACH DELETE n; // match to all nodes then detatch their relationships and delete their nodes

1.2.1- Create uniqueness constraints
    CREATE CONSTRAINT year_unique IF NOT EXISTS // uniquely constrain year property on Year nodes if it doesn't already exist
    FOR (y:Year) REQUIRE y.year IS UNIQUE; // require unique Year.year across all :Year nodes

    CREATE CONSTRAINT country_unique IF NOT EXISTS // create the constraint only if it does not already exist
    FOR (c:Country) REQUIRE c.name IS UNIQUE; // ensure the country's name is unique

    CREATE CONSTRAINT location_unique IF NOT EXISTS
    FOR (l:Location) REQUIRE l.name IS UNIQUE;

1.2.2- Load Eurovision Winners Data
    The following Year, Country, Location, and Entry nodes establish HOSTED_AT, Winning_Entry, and PERFORMED_BY relationships. Note eurovision\_location.csv is not loaded separately as it is a subset of this file (1.3 Design Rationale).

    LOAD CSV WITH HEADERS FROM 'file:///Eurovision_Winners.csv' AS row
    MERGE (y:Year {year: toInteger(row.Year)})
    MERGE (c:Country {name: toLower(trim(row.Country))})
    MERGE (l:Location {name: toLower(trim(row.Location))})
    CREATE (e:Entry {
        song: row.Song,
        artist: row.Artist,
        running_order: toInteger(row.Running_Order),
        total_points: toInteger(row.Total_Points)
    })
    MERGE (y)-[:HOSTED_AT]->(l)
    CREATE (y)-[:Winning_Entry]->(e)
    CREATE (e)-[:PERFORMED_BY]->(c);

    Merge tries to match a pattern and if no match is found then create the pattern

1.2.3- Load Voting Results Data

    Creates Vote nodes and ensures Country nodes exist for both voting (From) and receiving (To) countries. Establishes GAVE, TO, and HAD relationships so each vote is linked from the voting country to the receiving country via a Vote node.

    LOAD CSV WITH HEADERS FROM 'file:///eurovision_results.csv' AS row
    MERGE (from:Country {name: toLower(trim(row.From))})
    MERGE (to:Country {name: toLower(trim(row.To))})
    MERGE (y:Year {year: toInteger(row.Year)})
    CREATE (v:Vote {
        points: toInteger(row.Points),
        points_type: row.Points_type
    })
    CREATE (from)-[:GAVE]->(v)
    CREATE (v)-[:TO]->(to)
    CREATE (y)-[:HAD]->(v);

1.3 Design Rationale

1.3.1 NO RELATIONSHIP PROPERTIES: 

SET-EXERCISE 2.
Q: "Produce a Neo4j query to list all the countries that have won the competition more than twice. The query should include the country and be listed in descending order, that is the country which has won the greatest number of times should be listed first, followed by the country which has the second greatest, and so on. Your answer must show the query followed by the result with the columns appropriately named."

The below takes the database and formats it in a way that can be interogated

    LOAD CSV WITH HEADERS FROM 'file:///Eurovision_winners.csv' AS row
    MERGE (y:Year {year: toInteger(row.Year)})
    MERGE (c:Country {name: row.Country})
    MERGE (y)-[:Winning_Entry]->(c)

    Creates a Year 

    The below takes the reformated data and lists it as requested ( i.e. list all the countries that have won the competition more than twice)

    MATCH (y:Year)-[:Winning_Entry]->(c:Country)
    WITH c.name AS CountryName, count(y) AS TotalWins
    WHERE TotalWins > 2
    RETURN CountryName AS Country, TotalWins AS Wins
    ORDER BY Wins DESC

SET-EXERCISE 3.
Q: "Produce a Neo4j query to find all the host countries which then also went on to win the contest that year. The query should list the winning nations, the song they won with and the year in which they won returned in chronological order. You should submit the query and the result with the columns appropriately named."


LOAD CSV WITH HEADERS FROM 'file:///eurovision_location.csv' AS row
MATCH (y:Year {year: toInteger(row.Year)})
MERGE (c:Country {name: row.Country})
MERGE (y)-[:HOSTED_BY]->(c)

LOAD CSV WITH HEADERS FROM 'file:///Eurovision_Winners.csv' AS row
MATCH (y:Year {year: toInteger(row.Year)})
MATCH (c:Country {name: row.Country})
MATCH (y)-[r:Winning_Entry]->(c)
SET r.song = row.Song

MATCH (y:Year)-[w:Winning_Entry]->(c:Country)
WHERE (y)-[:HOSTED_BY]->(c)
RETURN c.name AS Winning_Nation, w.song AS Song, y.year AS Year
ORDER BY Year ASC


SET-EXERCISE 4.
Q: "Produce a Neo4j query to identify all the persistent friendships between countries. The query should list both countries and the number of points given. The query result should be listed in phabetical order by the country giving the points. You should submit the query and the result with the columns appropriately named."

MATCH (source:Country)-[:GAVE_POINTS]->(v:Vote)-[:ALLOCATED_TO]->(target:Country)
WITH source, target, sum(v.points) AS TotalPoints
RETURN source.name AS Country_Giving, target.name AS Country_Receiving, TotalPoints
ORDER BY Country_Giving ASC

AI DECLERATION:

I declare that I've used the AI tools listed below whilst preparing this assessment. I've read and understood the University of Plymouth's policy on the use of AI tools in assessment and confirm that my use falls within the coursework's allowed categories, i.e. {NO USE} 